.data
maze:	.ascii
	# 0123456701234567012345670123456701234567012345670123456701234567
	 "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",    # 0
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 1
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 2
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 3
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 4
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 5
	 "x                                                              x",    # 6
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 7
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 8
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 9
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 10
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 11
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 12
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 13
	 "x                                                              x",    # 14
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 15
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 16
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 17
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 18
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 19
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 20
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 21
	 "x                                                              x",    # 22
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 23
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 24
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 25
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 26
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 27
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 28
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 29
	 "x                                                              x",    # 30
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 31
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 32
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 33
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 34
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 35
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 36
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 37
	 "x                                                              x",    # 38
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 39
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 40
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 41
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 42
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 43
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 44
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 45
	 "x                                                              x",    # 46
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 47
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 48
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 49
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 50
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 51
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 52
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 53
	 "x                                                              x",    # 54
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 55
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 56
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 57
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 58
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 59
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 60
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 61
	 "x                                                               ",    # 62
	 "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  "     # 63
	# for each "x", turn the corresponding LED to orange.  The other LEDs should
	# be set to off.
	
# Messages to print to console when the game ends
	
gameovermessage: .asciiz "Sucess! you won! your score is "
moves: .asciiz " moves!"
lostmessage: .asciiz "Sorry. You were captured"
Zombie1x: .byte 0
Zombie1y: .byte 0
Zombie2x: .byte 0
Zombie2y: .byte 0
Zombie3x: .byte 0
Zombie3y: .byte 0
Zombie4x: .byte 0
Zombie4y: .byte 0
tempx: .byte 0
tempy: .byte 0
.text
# checks for the b button to be pressed to start the game, otherwise does nothing
restart:

la	$v0,0xffff0000		# address for reading key press status
	lw	$t0,0($v0)	# read the key press status
	andi	$t0,$t0,1
	beq	$t0,$0,restart	# no key pressed
	lw	$t0,4($v0)

addi	$v0,$t0,-66		# check for center key press
bne	$v0,$0, restart #if key pressed is not center key restart and check again for keypress

j startgame # Once center key is pressed game begins

startgame:

j setZombies # jump to setZombies method


#Method to put zombies in their starting positions
setZombies:
li $t4, 6 # Load $t4 with x position for zombie #1
li $t5, 1 # Load $t5 with y position for zombie #2
li $a2, 1 # Load $a2 with value 1 ( Color-red for zombie)
move $a0, $t4 # Move $t4 into x argument for setLED
move $a1, $t5 # Move $t5 into y argument for setLED
jal _setLED # jump and link setLED, making led at (6,1) red
li $t6, 33 # Load $t6 with x position for zombie #2
li $t7, 1 # Load $t7 with y position for zombie #2
move $a0, $t6 # Move $t6 into x argument for setLED
move $a1, $t7 # Move $t7 into y argument for setLED
jal _setLED # jump and link setLED, making led at (33,1) red
li $t8, 1 # Load $t8 with the x position for zombie #3
li $t9, 50 # Load $t9 with the y position for zombie #3
move $a0, $t8 # Move $t8 into x argument for setLED
move $a1, $t9 # Move $t9 into y argument for setLED
jal _setLED # jump and link setLED, making led at (1,33) red
li $s6, 33 # Load $s6 with the x position for zombie #4
li $s7, 33 # Load $s7 with the y position for zombie #4
move $a0, $s6 # Move $s6 into x argument for setLED
move $a1, $s7 # Move $s7 into y argument for setLED
jal _setLED # jump and link setLED, making led at (33,33) red



#Load maze onto the page

li $a0, 0 #x position of the beginning of the maze
li $a1, 0 #y position of the beginning of the maze
li $a2, 2 #sets color to yellow

j start #jump to start putting the maze on the page

start:
#prolouge
addi $sp, $sp, -20
sw   $s0, 0($sp)
sw   $s1, 4($sp)
sw   $s2, 8($sp)
sw   $s3, 12($sp)
sw   $ra, 16($sp)
li $s4, 64 # ending value for maze loop
la $s3, maze # load address of maze into $s3
move $s0, $a0 # puts starting x into $s0
move $s1, $a1 # pus starting y into $s1
move $s2, $a2 # puts starting color into $s2

loop:

slt $t2, $s1, $s4 # if x value is less than 64 $t2 is set to 1 otherwise set to 0
beq $t2, 0, game # if the x value is greater than 64 ($t2 = 0) branch to begin the game
lb $t1, 0($s3) # get first byte in the maze 
bne $t1, 0x78, black # if the byte does not equal "x" branch to black
li $a2, 2 # load value 2 into $a2 (sets color to yellow)

move $a0, $s0 # load x argument for setLED
move $a1, $s1 # load y argument for setLED
jal _setLED # jump and link to setLED setting (x,y) to yellow

black:
li $s2, 0 # load value 0 into $a2 (sets color to black)
addi $s0, $s0, 1 # add 1 to $s0 increasing x value
addi $s3, $s3, 1 # add 1 to $s3 increasing maze index

slt $t2, $s0, $s4 # if x < 64 set $t2 to 1 otherwise set to 0
beq $t2, 0, increasey # if x has reached 64 branch to increase y


j loop # loop again if x hasn't yet reached 64

increasey:
li $s0, 0 # set x back to zero
addi $s1, $s1, 1 # increase y value by 1
slt $t2, $s1, $s4 # if y < 64 $t2 = 1 otherwise set to 0
beq $t2, 0, game # if y has reached 64 branch to begin the game

j loop # loop again if y hasn't yet reached 64

# Epilouge
lw   $s0, 0($sp)
lw   $s1, 4($sp)
lw   $s2, 8($sp)
lw   $s3, 12($sp)
lw   $ra, 16($sp)
addi $sp, $sp, 20
jr $ra


game:

li $s4, 0 # Set moves counter to start at 0

li $v0, 30 # gets current time (initial time)
syscall

move $s5, $a0 # put start time from $a0 into $s5


li	$a2, 3 # loads $a2 with color green
li 	$a0, 1 # loads player inital x to be 1
li	$a1, 1 # loads player inital y to be 1
move $s0, $a0 # move $a0 into $s0 to save the players  x position
move $s1, $a1 # move $a1 into $s1 to save the players y position
jal	_setLED # jal to setLED, making LED at (1,1) green

	
gameloop:

keypress:
move $a0, $s0 # puts players current x position into argument $a0
move $a1, $s1 # puts players current y position into argument $a1
la	$v0,0xffff0000 # address for reading key press status
lw	$t0,0($v0) # read the key press status
andi	$t0,$t0,1
beq	$t0,$0, continue # if no key is pressed branch to continue	
lw	$t0,4($v0)
addi	$v0,$t0,-226 # check for left key press
beq	$v0,$0,lkey # branches to lkey method to move the player left
addi	$v0,$t0,-227 # check for right key press
beq	$v0,$0, rkey # branches to rkey method to move the player right
addi 	$v0, $t0, -224 # check for up key press
beq	$v0, $0, ukey # branches to ukey method to move the player up		
addi 	$v0, $t0, -225 # check for down key press
beq	$v0, $0, dkey # branches to down key method to move the player down
addi	$v0,$t0,-66 # check for center key press
beq	$v0,$0, bkey

continue:
	
li $v0, 30 # gets current time
syscall
sub $t3, $a0, $s5 # subtracts current time from the saved initial time and stores it in $t3
li $t1, 500 # load $t1 with value 500 (represents 500ms - used to check if zombies should be moved again)
slt $t2, $t3, $t1 # if (initial time - current time) < 500 $t2 is set to 1 otherwise it is set to equal
beq $t2, 1, continue # if it hasn't been 500ms jump back to continue and continue to check the time until it has been 500ms
	
move $s5, $a0 # save current time in $s5
	
move $a0, $s0 # put player x position into argument $a0 
move $a1, $s1 # put player y position into argument $a1

jal moveZombies # jump and link to the move zombies method



j gameloop # jump back to gameloop to continue the game

lkey:			
	move $a2, $a0 # put players x position into $a2
	move $a3, $a1 # put players y position into $a3
	addi $a0, $a0, -1 # subtract 1 from x
	addi $a1, $a1, 0 # y is unchanged
	jal movement # jump and link to movement method with arguments (x-1, y)
	beq $v1, 100, reset # if the player is not moved branch to reset
	move $s0, $v0 # save returned x value into $s0
	move $s1, $v1 # save returned y value into $s1
	move $a0, $s0 # put player x into argument $a0
	move $a1, $s1 # put player y into argument $a1
	j	continue # jump to continue
rkey:			
	move $a2, $a0 # put players x position into $a2
	move $a3, $a1 # put players y position into $a3
	addi $a0, $a0, 1 # add 1 to x
	addi $a1, $a1, 0 # y is unchanged
	beq $a0, 64, continue # if the player tries to exit the grid don't move the player (branch to continue)
	jal movement # jump and link to movement method with arguments (x+1, y)
	beq $v1, 100, reset # if the player is not moved branch to reset
	move $s0, $v0 # save returned x value into $s0
	move $s1, $v1 # save returned y value into $s1
	move $a0, $s0 # put player x into argument $a0
	move $a1, $s1 # put player y into argument $a1
	j	continue # jump to continue

ukey:
	move $a2, $a0 # put players x position into $a2
	move $a3, $a1 # put players y position into $a3
	addi $a0, $a0, 0 # x is unchanged
	addi $a1, $a1, -1 # subtract 1 from y
	jal movement # jump and link to movement method with arguments (x, y-1)
	beq $v1, 100, reset # if the player is not moved branch to reset
	move $s0, $v0 # save returned x value into $s0
	move $s1, $v1 # save returned y value into $s1
	move $a0, $s0 # put player x into argument $a0
	move $a1, $s1 # put player y into argument $a1
	j continue # jump to continue
dkey:
	
	move $a2, $a0 # put players x position into $a2
	move $a3, $a1 # put players y position into $a3
	addi $a0, $a0, 0 # x is unchanged
	addi $a1, $a1, 1 # add 1 to y
	beq $a1, 64, continue # if the player tries to exit the grid don't move player (branch to continue)
	jal movement # jump and link to movement method with argument (x, y+1)
	beq $v1, 100, reset # if the player is not moved branch to reset
	move $s0, $v0 # save returned x value argument $s0
	move $s1, $v1 # save returned y value argument $s1
	move $a0, $s0 # put player x into argument $a0
	move $a1, $s1 # put player y into argument $a1
	j continue # jump to continue
bkey:
	j continue # if b key is pressed ignore it
reset:
	move $a0, $a2 # if movement is unsuccessful move original x back into arguments
	move $a1, $a3 # if movement is unsuccessful move original y back into arguments

	
j continue # jump to continue

movement:	
#prolouge
	addi $sp, $sp, -12
	sw   $s2, 0($sp)
	sw   $s3, 4($sp)
	sw   $ra, 8($sp)
	move $s0, $a0	# move new x argument into $s0 register
	move $s1, $a1	# move new y argument into $s1 register
	move $s2, $a2	# move players previous x into $s2 register
	move $s3, $a3	# move players previous y into $s3 register
	jal _getLED	# jump and link to getLED to check whether it is a player or a wall
	beq $v0, 1, dead # if the led is red the player was captured and branch to captured message (dead)
	bne $v0, 2, set # if the led is not yellow (not a wall) branch to set
	
	li $v1, 100 #$v1 is 100 if it fails
	move $s0, $a2 # move x value into $s0 register
	move $s1, $a3 # move y value into $s1 register
	j end
set:	
	li $a2, 3 # load color argument with green
	move $a0, $s0 # put player x position into x argument for setLED
	move $a1, $s1 # put player y position into y argument for setLED
	jal _setLED # jump and link to setLED to set the player to its new position
	move $a0, $s2 # put player previous x position into x argument for setLED
	move $a1, $s3 # put player previous y position into y argument for setLED
	li $a2, 0 # load color argument with black
	jal _setLED # jump and link to setLED to set the players previous position to black
	move $a0, $s0 # move the players current x back into the x argument
	move $a1, $s1 # move the players current y back into the y argument
	move $a2, $s2 # move the players previous x into $a2
	move $a3, $s3 # move the players previous y into $a3
	
	addi $s4,$s4,1 # add one to the moves counter
	move $v0, $a0 # move player new x into return value for x
	move $v1, $a1 # move player new y into return value for y
	
beq $s0, 63, checky # check if the x value has reached 63
j end # if x hasnt reached 63 jump to the epilouge
checky: 
beq $s1, 63, gameover # check if the y value has reached 63 if so jump to gameover
	

end:
#epilouge
	lw   $s2, 0($sp)
	lw   $s3, 4($sp)
	lw   $ra, 8($sp)
	addi $sp, $sp, 12
	jr $ra


moveZombies:
#prolouge
addi $sp, $sp, -4
sw   $ra, 0($sp)


quad1:
li $t0, 32 # x max for quadrant 1
li $t1, 32 # y max for quadrant 1
slt $t2, $a0, $t0 # if players x position < 32 $t2 = 1
bne $t2, 1, quad2 # if $t2 = 1 the player is not in quad1 branch to quad2
slt $t3, $a1, $t1 # if players y position < 32 $t3 = 1
bne $t3, 1, quad2 # if $t3 = 1 the player is not in quad1 branch to quad2
move $a0, $t4 # put zombie1 x into the x argument for moveZombieInQuadrant 
move $a1, $t5 # put zombie1 y into the y argument for moveZombieInQuadrant
move $a2, $s0 # put players x position into $a2 for moveZombieInQuadrant
move $a3, $s1 # put players y position into $a3 for moveZombieInQuadrant

jal moveZombieInQuadrant # jump and link to moveZombieInQuadrant with the first zombie
move $t4, $v0 # put zombies new x position into $t4
move $t5, $v1 # put zombies new y position into $t5

#quad2
li $a2, 32 # x min for quadrant 2
li $a3, 31 # y max for quadrant 2
move $a0, $t6 # put zombie2 x into $a0 for moveZombieRandom
move $a1, $t7 # put zombie2 y into $a1 for moveZombieRandom
la $t0, Zombie2x # load address of Zombie2's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie2x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie2x into $t2 (tempx)
la $t0, Zombie2y # load address of Zombie2's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie2y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie2y into $t2 (tempy)
jal moveZombieRandom #have moveZombieRandom return the zombies position
la $t0, Zombie2x # load address of Zombie2x into $t0
sb $t6, ($t0) # store byte from Zombie2x into $t6 the x value for zombie 2
la $t1, Zombie2y # load address of Zombie2y into $t1
sb $t7, ($t1) # store byte from Zombie2y into $t7 the y value for zombie 2
move $t6, $v0 # move the new zombie x into $t6
move $t7, $v1 # move the new zombie y into $t7

#quad3
li $a2, 31 # x max for quadrant 3
li $a3, 32 # y min for quadrant 3
move $a0, $t8 # put zombie3 x into $a0 for moveZombieRandom
move $a1, $t9 # put zombie3 y into $a1 for moveZombieRandom
la $t0, Zombie3x # load address of Zombie3's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie3x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie3x into $t2 (tempx)
la $t0, Zombie3y # load address of Zombie3's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie3y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie3y into $t2 (tempy)
jal moveZombieRandom 
la $t0, Zombie3x # load address of Zombie3x into $t0
sb $t8, ($t0) # store byte from Zombie3x into $t8 the x value for zombie 3
la $t1, Zombie3y # load address of Zombie3y into $t1
sb $t9, ($t1) # store byte from Zombie3y into $t9 the y value for zombie 3
move $t8, $v0 # move the new zombie x into $t8
move $t9, $v1 # move the new zombie y into $t9

#quad4
li $a2, 32 # x min for quadrant 4
li $a3, 32 # y min for quadrant 4
move $a0, $s6 # put zombie4 x into $a0 for moveZombieRandom
move $a1, $s7 # put zombie4 y into $a1 for moveZombieRandom
la $t0, Zombie4x # load address of Zombie4's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie4x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie4x into $t2 (tempx)
la $t0, Zombie4y # load address of Zombie4's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie4y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie4y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie4x # load address of Zombie4x into $t0
sb $s6, ($t0) # store byte from Zombie4x into $s6 the x value for zombie 4
la $t1, Zombie4y # load address of Zombie4y into $t1
sb $s7, ($t1) # store byte from Zombie4y into $s7 the y value for zombie 4
move $s6, $v0 # move the new zombie x into $s6
move $s7, $v1 # move the new zombie y into $s7

j exitloop


quad2:
li $t0, 32 # x min for quadrant 2
li $t1, 32 # y max for quadrant 2
slt $t2, $a0, $t0 # if players x position is greater than 32 $t2 = 0
beq $t2, 0, check # if $t2 is 0 check the y coordinate ( branch to check )
j quad3 # otherwise jump to see if the player is in quadrant 3
check:
slt $t3, $a1, $t1 # if players y position is less than 32 $t3 = 1
beq $t3, 0, quad3 # if $t3 is 0 then branch to check quad3 otherwise it is in quad2
move $a0, $t6 # move zombie2's x coordinate into $a0 for moveZombieInQuadrant
move $a1, $t7 # move zombie2's y coordinate into $a1 for moveZombieInQuadrant
move $a2, $s0 # move players x into $a2
move $a3, $s1 # move player's y into $a3


jal moveZombieInQuadrant
move $t6, $v0 # put zombies new x into $t6
move $t7, $v1 # put zombies new y into $t7

#quad 1
li $a2, 31 # x max for quadrant 1
li $a3, 31 # y max for quadrant 1
move $a0, $t4 # put zombie1 x into $a0 for moveZombieRandom
move $a1, $t5 # put zombie1 y into $a1 for moveZombieRandom
la $t0, Zombie1x # load address of Zombie1's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie1x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie1x into $t2 (tempx)
la $t0, Zombie1y # load address of Zombie1's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie1y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie1y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie1x # load address of Zombie1x into $t0
sb $t4, ($t0) # store byte from Zombie1x into $t4 the x value for zombie 1
la $t1, Zombie1y # load address of Zombie1y into $t1
sb $t5, ($t1) # store byte from Zombie1y into $t5 the y value for zombie 1
move $t4, $v0 # move the new zombie x into $t4
move $t5, $v1 # move the new zombie y into $t5

#quad3
li $a2, 31 # x max for quadrant 3
li $a3, 32 # y min for quadrant 3
move $a0, $t8 # put zombie3 x into $a0 for moveZombieRandom
move $a1, $t9 # put zombie3 y into $a1 for moveZombieRandom
la $t0, Zombie3x # load address of Zombie3's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie3x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie3x into $t2 (tempx)
la $t0, Zombie3y # load address of Zombie3's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie3y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie2y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie3x # load address of Zombie3x into $t0
sb $t8, ($t0) # store byte from Zombie3x into $t8 the x value for zombie 3
la $t1, Zombie3y # load address of Zombie3y into $t1
sb $t9, ($t1) # store byte from Zombie37 into $t9 the y value for zombie 3
move $t8, $v0 # move the new zombie x into $t8
move $t9, $v1 # move the new zombie y into $t9

#quad4
li $a2, 32 # x min for quadrant 4
li $a3, 32 # y min for quadrant 4
move $a0, $s6 # put zombie4 x into $a0 for moveZombieRandom
move $a1, $s7 # put zombie4 y into $a1 for moveZombieRandom
la $t0, Zombie4x # load address of Zombie4's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie4x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie4x into $t2 (tempx)
la $t0, Zombie4y # load address of Zombie4's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie4y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie4y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie4x # load address of Zombie4x into $t0
sb $s6, ($t0) # store byte from Zombie4x into $s6 the x value for zombie 4
la $t1, Zombie4y # load address of Zombie4y into $t1
sb $s7, ($t1) # store byte from Zombie4y into $s7 the y value for zombie 4
move $s6, $v0 # move the new zombie x into $s6
move $s7, $v1 # move the new zombie y into $s7

j exitloop
quad3:
li $t0, 32 # x max for quadrant 3
li $t1, 31 # y min for quadrant 3
slt $t2, $a0, $t0 # if players x position is less than 32 $t2 = 1 
beq $t2, 1, check2 # if $t2 = 1 check the y position branch to check2
j quad4 # If it is not in quad3 jump to quad4 
check2:
slt $t3, $a1, $t1 # if players y position is greater than 31 $t3 = 0
bne $t3, 0, quad4 # if $t3 does not equal zero branch to quad4
move $a0, $t8 # put zombie3's x into x argument for moveZombieInQuadrant
move $a1, $t9 # put zombie3's y into y argument for moveZombieInQuadrant
move $a2, $s0 # put player's x position into $a2
move $a3, $s1 # put player's y position into $a3
jal moveZombieInQuadrant
move $t8, $v0 # move zombie's new x value into $t8
move $t9, $v1 # move zombie's new y value into $t9

#quad2
li $a2, 32 # x min for quadrant 2
li $a3, 31 # y max for quadrant 2
move $a0, $t6 # put zombie2 x into $a0 for moveZombieRandom
move $a1, $t7 # put zombie2 y into $a1 for moveZombieRandom
la $t0, Zombie2x # load address of Zombie2's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie2x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie2x into $t2 (tempx)
la $t0, Zombie2y # load address of Zombie2's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie2y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie2y into $t2 (tempy)
jal moveZombieRandom #have moveZombieRandom return the zombies position
la $t0, Zombie2x # load address of Zombie2x into $t0
sb $t6, ($t0) # store byte from Zombie2x into $t6 the x value for zombie 2
la $t1, Zombie2y # load address of Zombie2y into $t1
sb $t7, ($t1) # store byte from Zombie2y into $t7 the y value for zombie 2
move $t6, $v0 # move the new zombie x into $t6
move $t7, $v1 # move the new zombie y into $t7

#quad 1
li $a2, 31 # x max for quadrant 1
li $a3, 31 # y max for quadrant 1
move $a0, $t4 # put zombie1 x into $a0 for moveZombieRandom
move $a1, $t5 # put zombie1 y into $a1 for moveZombieRandom
la $t0, Zombie1x # load address of Zombie1's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie1x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie1x into $t2 (tempx)
la $t0, Zombie1y # load address of Zombie1's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie1y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie1y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie1x # load address of Zombie1x into $t0
sb $t4, ($t0) # store byte from Zombie1x into $t4 the x value for zombie 1
la $t1, Zombie1y # load address of Zombie1y into $t1
sb $t5, ($t1) # store byte from Zombie1y into $t5 the y value for zombie 1
move $t4, $v0 # move the new zombie x into $t4
move $t5, $v1 # move the new zombie y into $t5

#quad4
li $a2, 32 # x min for quadrant 4
li $a3, 32 # y min for quadrant 4
move $a0, $s6 # put zombie4 x into $a0 for moveZombieRandom
move $a1, $s7 # put zombie4 y into $a1 for moveZombieRandom
la $t0, Zombie4x # load address of Zombie4's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie4x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie4x into $t2 (tempx)
la $t0, Zombie4y # load address of Zombie4's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie4y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie4y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie4x # load address of Zombie4x into $t0
sb $s6, ($t0) # store byte from Zombie4x into $s6 the x value for zombie 4
la $t1, Zombie4y # load address of Zombie4y into $t1
sb $s7, ($t1) # store byte from Zombie4y into $s7 the y value for zombie 4
move $s6, $v0 # move the new zombie x into $s6
move $s7, $v1 # move the new zombie y into $s7

j exitloop
quad4:
move $a0, $s6 # put zombie4's x into x argument for moveZombieInQuadrant
move $a1, $s7 # put zombie4's x into y argument for moveZombieInQuadrant
move $a2, $s0 # put player's x position into $a2
move $a3, $s1 # put player's y position into $a3
jal moveZombieInQuadrant
move $s6, $v0 # put zombie's new x position into $s6
move $s7, $v1 # put zombie's new y position into $s7


#quad2
li $a2, 32 # x min for quadrant 2
li $a3, 31 # y max for quadrant 2
move $a0, $t6 # put zombie2 x into $a0 for moveZombieRandom
move $a1, $t7 # put zombie2 y into $a1 for moveZombieRandom
la $t0, Zombie2x # load address of Zombie2's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie2x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie2x into $t2 (tempx)
la $t0, Zombie2y # load address of Zombie2's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie2y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie2y into $t2 (tempy)
jal moveZombieRandom #have moveZombieRandom return the zombies position
la $t0, Zombie2x # load address of Zombie2x into $t0
sb $t6, ($t0) # store byte from Zombie2x into $t6 the x value for zombie 2
la $t1, Zombie2y # load address of Zombie2y into $t1
sb $t7, ($t1) # store byte from Zombie2y into $t7 the y value for zombie 2
move $t6, $v0 # move the new zombie x into $t6
move $t7, $v1 # move the new zombie y into $t7


#quad3
li $a2, 31 # x max for quadrant 3
li $a3, 32 # y min for quadrant 3
move $a0, $t8 # put zombie3 x into $a0 for moveZombieRandom
move $a1, $t9 # put zombie3 y into $a1 for moveZombieRandom
la $t0, Zombie3x # load address of Zombie3's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie3x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie3x into $t2 (tempx)
la $t0, Zombie3y # load address of Zombie3's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie3y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie2y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie3x # load address of Zombie3x into $t0
sb $t8, ($t0) # store byte from Zombie3x into $t8 the x value for zombie 3
la $t1, Zombie3y # load address of Zombie3y into $t1
sb $t9, ($t1) # store byte from Zombie37 into $t9 the y value for zombie 3
move $t8, $v0 # move the new zombie x into $t8
move $t9, $v1 # move the new zombie y into $t9

#quad 1
li $a2, 31 # x max for quadrant 1
li $a3, 31 # y max for quadrant 1
move $a0, $t4 # put zombie1 x into $a0 for moveZombieRandom
move $a1, $t5 # put zombie1 y into $a1 for moveZombieRandom
la $t0, Zombie1x # load address of Zombie1's previous x into $t0
lb $t1, 0($t0) # load byte from Zombie1x into $t1
la $t2, tempx # load address of tempx into $t2
sb $t1, ($t2) # store byte from Zombie1x into $t2 (tempx)
la $t0, Zombie1y # load address of Zombie1's previous y into $t0
lb $t1, 0($t0) # load byte from Zombie1y into $t1
la $t2, tempy # load address from tempy into $t2
sb $t1, ($t2) # store byte from Zombie1y into $t2 (tempy)
jal moveZombieRandom
la $t0, Zombie1x # load address of Zombie1x into $t0
sb $t4, ($t0) # store byte from Zombie1x into $t4 the x value for zombie 1
la $t1, Zombie1y # load address of Zombie1y into $t1
sb $t5, ($t1) # store byte from Zombie1y into $t5 the y value for zombie 1
move $t4, $v0 # move the new zombie x into $t4
move $t5, $v1 # move the new zombie y into $t5
j exitloop

exitloop:
#epilouge
lw   $ra, 0($sp)
addi $sp, $sp, 4
jr $ra


moveZombieInQuadrant:
#prolouge
addi $sp, $sp, -12
sw   $s2, 0($sp)
sw   $s3, 4($sp)
sw   $ra, 8($sp)


move $s2, $a0 #put zombie x position into $s2 
move $s3, $a1 #put zombie y position into $s3
beq $a0, $a2, moveYdirection # if the zombie's x position = player's x position branch to move in the y direction
beq $a1, $a3, moveXdirection # if the zombie's y position = player's y position branch to move in the x direction

moveXdirection:
moveLeft:

slt $t1, $a2, $a0 # if the player's x position is less than the zombies $t1 is set to 1
bne $t1, 1, moveRight # if the player's x position is not less than the zombies branch to move right
move $a0, $s2 # put zombie's x position into $a0
move $a1, $s3 # put zombie's y position into $a1
addi $a0, $a0, -1 # subtract 1 from zombie's x position
jal _getLED # getLED to check for a wall/player
beq $v0, 2, moveYdirection # if the zombie is trying to move into a wall branch to move in the y direction
beq $v0, 3, dead # if the zombie tries to move onto a player branch to captured message (dead)
li $a2, 1 # if the move can be made load color with red
jal _setLED # set led at new position 

addi $a0, $a0, 1 # add one back to the x position
li $a2, 0 # load color as black
jal _setLED # set led at previous position to black
addi $s2, $s2, -1 # update zombie x position to be saved
j endloop # jump to epilouge

moveRight:
move $a0, $s2 # put zombie x into $a0
move $a1, $s3 # put zombie y into $a1
addi $a0, $a0, 1 # add 1 to zombie's x position
li $a2, 1 # load red into $a2 
jal _getLED # check the color of the led in the position the zombie is trying to move to
beq $v0, 2, moveLeft # if the zombie is trying to move into a wall try moving left
beq $v0, 3, dead # if the zombie moves onto the player branch to captured message
jal _setLED # if move can be made set that led to red

addi $a0, $a0, -1 # subtract 1 from x argument
li $a2, 0 # set color to black
jal _setLED # set the led at the zombie's previous position to black
addi $s2, $s2, 1 # add 1 to the zombie's x position
j endloop 
moveYdirection:
moveUp:
move $a0, $s2 # put zombie x into $a0
move $a1, $s3 # put zombie y into $a1
slt $t1, $a3, $a1 # if players y position is less than the zombie's y position $t1 = 1
bne $t1, 1, moveDown # if the player's y position is not less than the zombie's branch to movedown
move $a0, $s2 # put the zombie x into $a0
move $a1, $s3 # put the zombie y into $a1
addi $a1, $a1, -1 # subtract 1 from the zombie's y position
jal _getLED # check the color of the led in the position the zombie is trying to move to
beq $v0, 2, moveDown # if the zombie is trying to move into a wall try moving down
beq $v0, 3, dead # if the zombie moves onto the player branch to captured message
li $a2, 1 # load red into $a2
jal _setLED # if the zombie can be moved set the led to red

addi $a1, $a1, 1 # add 1 to the zombie's y position
li $a2, 0 # load color $a2 black
jal _setLED # set led at zombie's previous position to black
addi $s3, $s3, -1 # subtract 1 from the zombie's y position
j endloop
moveDown:
move $a0, $s2 # put zombie x into $a0
move $a1, $s3 # put zombie y into $a1
addi $a1, $a1, 1 # add 1 to the zombie's y position
li $a2, 1 # load color at $a2 red
jal _getLED # check the color of the led in the position the zombie is trying to move to
beq $v0, 2, moveXdirection # if the zombie is trying to move into a wall try moving in the xdirection
beq $v0, 3, dead # if the zombie moves onto the player branch to captured message
jal _setLED # if the zombie can be moved the led to red

addi $a1, $a1, -1 # subtract 1 from the zombie's y position 
li $a2, 0 # load $a2 with the color argument black
jal _setLED # set the led of the zombie's previous position to black
addi $s3, $s3, 1 # add 1 to the zombie's y position
j endloop

endloop:



li $v0, 30 # calculate current time
syscall


move $s5, $a0 # save current time in $s5

move $v0, $s2 # put zombie's new x into $v0
move $v1, $s3 # put zombie's new y into $v1

#epilouge
lw $s2, 0($sp)
lw $s3, 4($sp)
lw   $ra, 8($sp)
addi $sp, $sp, 12
jr $ra


dead:
li $a2, 1 # load color with red
jal _setLED # set the led to red
move $a0, $s2 # put the zombie's previous x into $a0
move $a1, $s3 # put the zombie's previous y into $a1
li $a2, 0 # load color with black
jal _setLED # set the led to black
# print out lost message
li $v0, 4 
la $a0, lostmessage
syscall
# end program
li $v0, 10
syscall



gameover:
# print out success message
li $v0, 4
la $a0, gameovermessage
syscall
# print out number of moves
li $v0, 1
la $a0, ($s4)
syscall
# print out moves message
li $v0, 4
la $a0, moves
syscall
# end program
li $v0, 10
syscall



moveZombieRandom:
# prolouge
addi $sp, $sp, -4
sw $ra, 0($sp)

move $t1, $a2 # what x cant be 
move $t2, $a3 # what y cant be
la $t0, tempx # load address of tempx
lb $t3, 0($t0) # load byte from tempx into $t3
la $s2, tempy # load address of tempy
lb $s3, 0($s2) # load byte from tempy into $s3

move $a2, $a0 # move x into $a2
move $a3, $a1 # move y into $a3

li $s2, 0 # set $s2 to 0 - the counter to check whether each direction has been tried 

Random:
beq $s2, 15, setZombieBack # if all directions have been tried $s2 = 15 and zombie is allowed to backtrack
li $a1, 4 
li $v0, 42 #generates random number betweeen 0 and 3
syscall
move $t0, $a0 # put random number into $t0
move $a0, $a2 # put x into $a0 argument
move $a1, $a3 # put y into $a1 argument


beq $t0, 0, left # if the random number is 0 branch to left movement method
beq $t0, 1, right # if the random number is 1 branch to right movement method
beq $t0, 2, up # if the random number is 2 branch to the up movement method
beq $t0, 3, down # if the random number is 3 branch to the down movement method
j Random


left:
ori $s2, $s2, 1 # or $s2 with 1 when left is tried
addi $a0, $a0, -1 # subtract 1 from the x value
beq $t3, $a0, Random # if the new x value is equal to the previous x positon find a new direction
beq $a0, $t1, Random # if the new x value is at the boundary find a new direction
jal _getLED # get led color of position zombie is trying to move to
beq $v0, 2, Random # if led is a wall find new direction 
beq $v0, 3, dead # if led is a player branch to captured message

li $a2, 1 # load color with red
jal _setLED # set led for zombie movement
move $v0, $a0 # load zombie's x into return value for x
move $v1, $a1 # load zombie's y into return value for y
addi $a0, $a0, 1 # add 1 to zombie's x
li $a2, 0 # load color with black
jal _setLED # set led of zombie's previous position with black
j endRandom

right:
ori $s2,$s2,2 # or $s2 with 2 when right is tried
addi $a0, $a0, 1 # add 1 to the x value
beq $t3, $a0, Random # if the new x value is equal to the previous x positon find a new direction
beq $a0, $t1, Random # if the new x value is at the boundary find a new direction
jal _getLED # get led color of position  the zombie is trying to move to
beq $v0, 2, Random # if led is a wall find new direction 
beq $v0, 3, dead # if led is a player branch to captured message
li $a2, 1 # load color with red
jal _setLED # set led for zombie movement
move $v0, $a0 # load zombie's x into return value for x
move $v1, $a1 # load zombie's y into return value for y
addi $a0, $a0, -1 # subtract 1 from zombie's x
li $a2, 0 # load color with black 
jal _setLED # set led of zombie's previous position with black
j endRandom

up:
ori $s2,$s2, 4 # or $s2 with 4 when up is tried
addi $a1, $a1, -1 # subtract 1 from the y value
beq $s3, $a1, Random # if the new y value is equal to the previous y position find a new direction
beq $t2, $a1, Random # if the new y value is at the boundary find a new direction
jal _getLED # get led color of position the zombie is trying to move to 
beq $v0, 2, Random # if led is a wall find new direction
beq $v0, 3, dead # if led is a player branch to captured message
li $a2, 1 # load color with red
jal _setLED # set led for zombie movement
move $v0, $a0 # load zombie's x into return value for x
move $v1, $a1 # load zombie's y into return value for y
addi $a1, $a1, 1 # adds one to the zombie's y
li $a2, 0 # set color to black
jal _setLED # set led of zombie's previous position with black
j endRandom


down:
ori $s2,$s2, 8 # or $s2 with 8 when down is tried
addi $a1, $a1, 1 # add 1 to the y value
beq $s3, $a1, Random # if the new y value is equal to the previous y position find a new direction
beq $t2, $a1, Random # if the new y value is at the boundary find a new direction
jal _getLED # get led color of position the zombie is trying to move to 
beq $v0, 2, Random # if led is a wall find new direction
beq $v0, 3, dead # if led is a player branch to captured message
li $a2, 1 # load color with red
jal _setLED # set led for zombie movement
move $v0, $a0 # load zombie's x into return value for x
move $v1, $a1 # load zombie's y into return value for y
addi $a1, $a1, -1 # subtracts 1 from zombies y
li $a2, 0 # loads color with black
jal _setLED # set led of zombie's previous position with black
j endRandom

setZombieBack:
# backtracks the zombies
li $a2,0
jal _setLED
la $t0, tempx
lb $v0, ($t0)
la $t1, tempy
lb $v1, ($t1)
move $a0, $v0
move $a1, $v1
li $a2, 1
jal _setLED


endRandom:
#epilouge
lw $ra, 0($sp)
addi $sp, $sp, 4
jr $ra






# _setLED and _getLED functions for Keypad and LED Display Simulator (64x64)
#
# These functions may be used in your CS/CoE 0447 Project 1.
# They provide a convenient interface to the Keypad and LED Display Simulator
# extension (64x64) in Mars4_5-Pitt.  For arguments and return values,
# read the comments above each; call them like any other MIPS function.
#
# If you're really interested, look through the code to show yourself
# how it works, or even practice writing these yourself!  You know
# all the pieces; try fitting them together!


	# void _setLED(int x, int y, int color)
	#   sets the LED at (x,y) to color
	#   color: 0=off, 1=red, 2=yellow, 3=green
	#
	# arguments: $a0 is x, $a1 is y, $a2 is color
	# trashes:   $t0-$t3
	# returns:   none
	#
_setLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll	$t0,$a1,4      # y * 16 bytes
	srl	$t1,$a0,2      # x / 4
	add	$t0,$t0,$t1    # byte offset into display
	li	$t2,0xffff0008 # base address of LED display
	add	$t0,$t2,$t0    # address of byte with the LED
	# now, compute led position in the byte and the mask for it
	andi	$t1,$a0,0x3    # remainder is led position in byte
	neg	$t1,$t1        # negate position for subtraction
	addi	$t1,$t1,3      # bit positions in reverse order
	sll	$t1,$t1,1      # led is 2 bits
	# compute two masks: one to clear field, one to set new color
	li	$t2,3		
	sllv	$t2,$t2,$t1
	not	$t2,$t2        # bit mask for clearing current color
	sllv	$t1,$a2,$t1    # bit mask for setting color
	# get current LED value, set the new field, store it back to LED
	lbu	$t3,0($t0)     # read current LED value	
	and	$t3,$t3,$t2    # clear the field for the color
	or	$t3,$t3,$t1    # set color field
	sb	$t3,0($t0)     # update display
	jr	$ra
	
	# int _getLED(int x, int y)
	#   returns the value of the LED at position (x,y)
	#
	#  arguments: $a0 holds x, $a1 holds y
	#  trashes:   $t0-$t2
	#  returns:   $v0 holds the value of the LED (0, 1, 2 or 3)
	#
_getLED:
addi $sp, $sp, -12
sw $t0, 0($sp)
sw $t1, 4($sp)
sw $t2, 8($sp)
	# byte offset into display = y * 16 bytes + (x / 4)
	sll  $t0,$a1,4      # y * 16 bytes
	srl  $t1,$a0,2      # x / 4
	add  $t0,$t0,$t1    # byte offset into display
	la   $t2,0xffff0008
	add  $t0,$t2,$t0    # address of byte with the LED
	# now, compute bit position in the byte and the mask for it
	andi $t1,$a0,0x3    # remainder is bit position in byte
	neg  $t1,$t1        # negate position for subtraction
	addi $t1,$t1,3      # bit positions in reverse order
    	sll  $t1,$t1,1      # led is 2 bits
	# load LED value, get the desired bit in the loaded byte
	lbu  $t2,0($t0)
	srlv $t2,$t2,$t1    # shift LED value to lsb position
	andi $v0,$t2,0x3    # mask off any remaining upper bits
lw $t0, 0($sp)
lw $t1, 4($sp)
lw $t2, 8($sp)
addi $sp, $sp, 12
	jr   $ra
